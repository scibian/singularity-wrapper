#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (C) 2017 EDF SA
# Contact:
#       CCN - HPC <dsp-cspit-ccn-hpc@edf.fr>
#       1, Avenue du General de Gaulle
#       92140 Clamart
#
# Authors: CCN - HPC <dsp-cspit-ccn-hpc@edf.fr>
#
# This file is part of singularity-wrapper.
#
# singularity-wrapper is free software: you can redistribute in and/or
# modify it under the terms of the GNU General Public License,
# version 2, as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with puppet-hpc. If not, see
# <http://www.gnu.org/licenses/>.

import locale
import logging
logger = logging.getLogger(__name__)
import sys
import os
import argparse
import configparser
from io import StringIO
import shutil
import tempfile
import jinja2
import distutils
from distutils import dir_util
import subprocess
import email
from email import utils
import apt_inst
import apt_pkg
import time
import urllib
from urllib import parse
import http
from http import client
import ssl
from string import Template

VERSION = '1.1'
LOCALE = 'C.UTF-8'


class AppConf():
    """Runtime configuration class."""

    def __init__(self):
        self.debug = False
        self.conf_file = None

        self.action = None

        self.global_skip_clean = None
        self.global_ssl_ca_crt = None

        self.images_desc_dir = None
        self.images_build_root = None

        self.recipes_dir = None
        self.recipes_tpl_name = None
        self.recipes_ssl_crt = None
        self.recipes_ssl_key = None

        self.wrapper_maintainer = None
        self.wrapper_dist = None
        self.wrapper_source_dir = None

        self.repos_active = None
        self.repos_excluded_deps = None
        self.repos_default_arch = None

        self.repos = None

        self.oneImage = None

    def dump(self):
        logger.debug("runtime configuration dump:")
        logger.debug("- action: %s", str(self.action))
        logger.debug("- debug: %s", str(self.debug))
        logger.debug("- conf_file: %s", str(self.conf_file))
        logger.debug("- global_skip_clean: %s", str(self.global_skip_clean))
        logger.debug("- global_ssl_ca_crt: %s", str(self.global_ssl_ca_crt))
        logger.debug("- images_desc_dir: %s", str(self.images_desc_dir))
        logger.debug("- images_build_root: %s", str(self.images_build_root))
        logger.debug("- recipes_dir: %s", str(self.recipes_dir))
        logger.debug("- recipes_tpl_name: %s", str(self.recipes_tpl_name))
        logger.debug("- recipes_ssl_crt: %s", str(self.recipes_ssl_crt))
        logger.debug("- recipes_ssl_key: %s", str(self.recipes_ssl_key))
        logger.debug("- wrapper_maintainer: %s", str(self.wrapper_maintainer))
        logger.debug("- wrapper_dist: %s", str(self.wrapper_dist))
        logger.debug("- wrapper_source_dir: %s", str(self.wrapper_source_dir))
        logger.debug("- repos_active: %s", str(self.repos_active))
        logger.debug("- repos_excluded_deps: %s", str(self.repos_excluded_deps))
        logger.debug("- repos_default_arch: %s", str(self.repos_default_arch))
        for name, repo in self.repos.items():
            logger.debug("- repos: %s", str(name))
            logger.debug("  * base_url: %s", str(repo['base_url']))
            logger.debug("  * ssl_key: %s", str(repo['ssl_key']))
            logger.debug("  * ssl_crt: %s", str(repo['ssl_crt']))
            logger.debug("  * components: %s", str(repo['components']))
            logger.debug("  * dist: %s", str(repo['dist']))
            logger.debug("  * archs: %s", str(repo['archs']))
            logger.debug("  * dist_release: %s", str(repo['dist_release']))


class ImageDesc():

    def __init__(self, name, file_path):
        self.name = name
        self.file_path = file_path

        parser = configparser.ConfigParser()
        parser.read(file_path)

        self.app_path = parser.get('app', 'path')
        self.app_packages = parser.get('app', 'packages').split(',')
        self.dist_name = parser.get('dist', 'name')


class Image():

    STATUS_UNKNOWN = 0
    STATUS_PRESENT = 1
    STATUS_MISSING = 2

    @staticmethod
    def get_status_string(status):
        if status == Image.STATUS_PRESENT:
            return 'PRESENT'
        elif status == Image.STATUS_MISSING:
            return 'MISSING'
        else:
            return 'UNKNOWN'

    def __init__(self, name, desc):
        self.name = name
        self.desc = desc
        self.dist = self.desc.dist_name
        app_path = self.desc.app_path
        if os.path.isabs(app_path):
            app_path = app_path[1:]
        self.path = os.path.join(conf.images_build_root,
                                 app_path,
                                 "%s_%s.img" % (self.dist, self.name))
        self.status = Image.STATUS_UNKNOWN

    def refresh_state(self):
        if os.path.isfile(self.path):
            self.status = Image.STATUS_PRESENT
        else:
            self.status = Image.STATUS_MISSING

    def build(self):
        workdir = self._build_create_workdir()
        self._build_actual(workdir)
        self._build_clean_workdir(workdir)
        self.refresh_state()

    def _build_create_workdir(self):
        # Create temp dir
        workdir = tempfile.mkdtemp(
            prefix='singularity_wrapper_img_build_%s' % self.name
        )
        # Create recipe
        tpl_name = Template(conf.recipes_tpl_name).substitute(dist=self.dist)
        tpl_filename = "%s.def.tpl" % tpl_name
        context = {
            'app_packages': ' '.join(self.desc.app_packages)
        }
        jinja2_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(conf.recipes_dir)
        )
        tpl = jinja2_env.get_template(tpl_filename)
        rendered_content = tpl.render(context)
        recipe_path = os.path.join(workdir, 'recipe.def')
        open(recipe_path, 'w').write(rendered_content)
        # Copy common files
        files_common_path = os.path.join(conf.recipes_dir, 'files_common')
        if os.path.isdir(files_common_path):
            distutils.dir_util.copy_tree(files_common_path, workdir)
        # Copy template files
        files_tpl_path = os.path.join(
            conf.recipes_dir,
            'files_%s' % conf.recipes_tpl_name
        )
        if os.path.isdir(files_tpl_path):
            distutils.dir_util.copy_tree(files_tpl_path, workdir)
        # Copy Certs
        dst_crt_path = os.path.join(workdir, 'ssl-cert.pem')
        dst_key_path = os.path.join(workdir, 'ssl-cert.key')
        if os.access(conf.recipes_ssl_crt, os.R_OK):
            logger.debug("Copying SSL cert from %s to %s.",
                         conf.recipes_ssl_crt, dst_crt_path)
            shutil.copy2(conf.recipes_ssl_crt, dst_crt_path)
        else:
            logger.warning("SSL Cert is not readable: %s.",
                           conf.recipes_ssl_crt)
        if os.access(conf.recipes_ssl_key, os.R_OK):
            logger.debug("Copying SSL key from %s to %s." % (
                         conf.recipes_ssl_key, dst_key_path))
            shutil.copy2(conf.recipes_ssl_key, dst_key_path)
        else:
            logger.warning("SSL Key is not readable: %s.",
                           conf.recipes_ssl_key)
        logger.debug("Workdir for building %s is ready: %s" % (
            self.name, workdir))
        return workdir

    def _build_actual(self, workdir):
        # Launch Singularity Build
        recipe_path = os.path.join(workdir, 'recipe.def')
        build_img_path = "%s.tmp" % self.path
        return_code = subprocess.call(
            ['/usr/bin/singularity', 'build', build_img_path, recipe_path],
            cwd=workdir
        )
        logger.debug("Singularity Image build returned: %d", return_code)
        if return_code > 0:
            logger.error("Failed to build image %s on %s", self.name, self.path)
        os.chmod(build_img_path, 0o755)
        os.replace(build_img_path, self.path)

    def _build_clean_workdir(self, workdir):
        if conf.global_skip_clean:
            return
        if os.path.isdir(workdir):
            robust_rmtree(workdir)


class Repository():

    def __init__(self, name):
        self.name = name
        self.base_url = conf.repos[self.name]['base_url']
        self.ssl_key = conf.repos[self.name]['ssl_key']
        self.ssl_crt = conf.repos[self.name]['ssl_crt']
        self.components = conf.repos[self.name]['components']
        self.dist = conf.repos[self.name]['dist']
        self.dist_release = conf.repos[self.name]['dist_release']
        self.archs = conf.repos[self.name]['archs']
        self.packages = None

    def _download_file(self, path, file_path):
        url = "%s/%s" % (self.base_url, path)
        download_file(file_path, url, self.ssl_crt, self.ssl_key)

    def _download_packages_file(self, component, arch, file_path):
        path = "dists/%s/%s/binary-%s/Packages.gz" % (
            self.dist, component, arch
        )
        self._download_file(path, file_path)

    def _add_packages_file(self, packages, packages_path):
        packages_file = open(packages_path)
        for section in apt_pkg.TagFile(packages_file):
            info = {}
            for field in section.keys():
                f_name = str(field)
                try:
                    f_value = section.get(field)
                except UnicodeDecodeError as e:
                    logger.warning("Failed to decode %s: %s", f_name, e)
                    if f_name == 'Description':
                        f_value = ''
                    else:
                        continue
                if f_name in ['Depends', 'Pre-Depends']:
                    value = apt_pkg.parse_depends(f_value)
                else:
                    value = f_value
                info[f_name] = value
            if 'Package' not in info.keys() \
                    and 'Architecture' not in info.keys():
                logger.warning("Invalid package %s", info)
                continue
            pkg_full_name = "%s:%s" % (info['Package'], info['Architecture'])
            packages[pkg_full_name] = info
        packages_file.close()

    def _init(self):
        if self.packages is not None:
            return
        packages = {}
        tmpfile = tempfile.mktemp()
        for arch in self.archs:
            for component in self.components:
                self._download_packages_file(component, arch, tmpfile)
                self._add_packages_file(packages, tmpfile)
        os.remove(tmpfile)
        self.packages = packages

    def get_packages(self, queries=None, excluded_deps=None):
        self._init()
        result = {}
        for name, info in self.packages.items():
            # Test query matching
            if queries is not None \
                    and name not in queries \
                    and info['Package'] not in queries:
                logger.debug(
                    "Package %s do not match any query %s",
                    name, queries
                )
                continue

            # Test dependency exclusion
            excluded = False
            for dep_type in ['Depends', 'Pre-Depends']:
                if dep_type in info.keys():
                    for dep_alternatives in info[dep_type]:
                        for pkg, ver, op in dep_alternatives:
                            if pkg in excluded_deps:
                                logger.debug(
                                    "Package %s excluded because of dep %s",
                                    name, pkg
                                )
                                excluded = True
                            else:
                                logger.debug(
                                    "Dependency %s is ok for package %s",
                                    pkg, name
                                )

            if excluded:
                continue
            result[name] = info
        logger.debug("Matching packages are: %s", result.keys())
        return result

    def download_package(self, pkg_name, file_path):
        info = self.get_package_info(pkg_name)
        path = info['Filename']
        self._download_file(path, file_path)

    def get_package_info(self, pkg_name):
        packages = self.get_packages(
            queries=[pkg_name],
            excluded_deps=conf.repos_excluded_deps
        )
        if len(packages) == 0:
            return None
        for name, info in packages.items():
            if info['Architecture'] == conf.repos_default_arch:
                return info
            last = info
        return last

    def get_package(self, pkg_name):
        info = self.get_package_info(pkg_name)
        if info is None:
            return None
        tmpfile = tempfile.mktemp()
        self.download_package(pkg_name, tmpfile)
        pkg = BinaryPackage(tmpfile)
        return pkg


class BinaryPackage():

    def __init__(self, filepath):
        self.realpath = os.path.realpath(filepath)
        self.filename = os.path.basename(self.realpath)
        self.debfile = apt_inst.DebFile(self.realpath)
        self.data_members = {}
        self.debfile.data.go(self._add_data_member)
        # Create temp file
        control_path = tempfile.mktemp()
        # Extract control file
        control = self.debfile.control.extractdata("control")
        control_file = open(control_path, 'wb')
        control_file.write(control)
        control_file.close()
        # Parse control file
        control_file = open(control_path)
        self.control_fields = {}
        for section in apt_pkg.TagFile(control_file):
            for field in section.keys():
                self.control_fields[str(field)] = section.get(field)
            logger.debug('Found fields: %s', self.control_fields)
        self.name = self.control_fields['Package']
        self.version = self.control_fields['Version']
        control_file.close()
        # Clean tempfile
        os.remove(control_path)

    def get_app_path(self):
        # per the applis spec, should be /opt/name/X.Y or /opt/name-X.Y,
        #  /opt/name
        if "opt/%s/" % self.name in self.data_members.keys():
            return "/opt/%s/" % self.name
        if self.name.find('-') >= 0:
            [base_name, version] = self.name.rsplit('-', 1)
            if "opt/%s/%s/" % (base_name, version) in self.data_members.keys():
                return "/opt/%s/%s/" % (base_name, version)
        return None

    def get_app_exe(self):
        if "usr/bin/%s" % self.name in self.data_members.keys():
            return "/usr/bin/%s" % self.name
        return None

    def _add_data_member(self, member, data):
        self.data_members[member.name] = member

    def is_member(self, member_name):
        return member_name in self.data_members.keys()

    def get_member_names(self, prefix=''):
        member_names = []
        for member_name in self.data_members.keys():
            if member_name.startswith(prefix):
                member_names.append(member_name)
        return member_names

    def get_member_sym_target(self, member_name):
        member = self.data_members[member_name]
        if member.issym():
            return member.linkname
        else:
            return None

    def get_member_content(self, member_name):
        return self.debfile.data.extractdata(member_name)

class SrcPackage():
	
	def __init__(self, package):
		self.context = {}
		self.pkg = package['package']
		self.context['package_maintainer'] = conf.wrapper_maintainer
		self.package_name = self.pkg.name
		self.package_dist = package['source_dist']
		self.context['package_date'] = email.utils.formatdate()
		self.version = self.pkg.version
		self.context['package_orig_name'] = self.pkg.name
		self.context['package_orig_version'] = self.pkg.version
		app_path = self.pkg.get_app_path()
		if app_path is None:
			# There is no application path, we make our own
			if self.pkg.name.find('-') >= 0:
				[base_name, version] = self.pkg.name.rsplit('-', 1)
				app_path = "/opt/%s/%s/" % (base_name, version)
			else:
				app_path = "/opt/%s" % self.pkg.name
		self.app_path = app_path
		self.app_exe = self.pkg.get_app_exe()


class Wrapper():

    def __init__(self, packages):
        self.srcPackages = []
        for pkg in packages.values():
            self.srcPackages.append(SrcPackage(pkg))
        main_name = self.srcPackages[0].pkg.name
        self.name = 'singularity-wrapper-%s' % main_name
        self.context = {}
        self.context['singularity_wrapper_version'] = VERSION
        self.context['main_name'] = main_name
        self.context['package_date'] = email.utils.formatdate()
        #instantiate list of packages
        self.image_desc = self.srcPackages[0].package_name
        app_path = self.srcPackages[0].app_path
        self.context['app_path'] = 	app_path
        dist = self.srcPackages[0].package_dist
        self.context['package_dist'] = dist 
        self.context['image_path'] = os.path.join(
            app_path, "%s_%s.img" % (dist, main_name)
        )
        packages_names = ', '.join(x.package_name for x in self.srcPackages)

        app_exe = ', '.join(str(x.app_exe) for x in self.srcPackages)
        self.context['package_orig_name'] = packages_names
        self.context['package_version'] = self.srcPackages[0].version
        self.context['package_name'] = self.name
        self.context['app_exe'] = app_exe
        self.context['package_maintainer'] = conf.wrapper_maintainer
        template_dir = os.path.join(conf.wrapper_source_dir, 'templates')
        self.jinja2_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(template_dir)
        )


    def _build_create_workdir(self):
        # Create temp dir
        workdir = tempfile.mkdtemp(
            prefix='singularity_wrapper_img_build_%s' % self.name
        )
        # Create source dir
        source_dir = os.path.join(workdir, 'source')
        os.mkdir(source_dir)
        # Copy static files
        files_dir = os.path.join(conf.wrapper_source_dir, 'files')
        distutils.dir_util.copy_tree(files_dir, source_dir)
        # Template: control
        dest_path = os.path.join(source_dir, 'debian/control')
        write_rendered_template(
            self.jinja2_env, 'debian/control.tpl', self.context, dest_path
        )
        # Template: changelog
        dest_path = os.path.join(source_dir, 'debian/changelog')
        write_rendered_template(
            self.jinja2_env, 'debian/changelog.tpl', self.context, dest_path
        )
        # Template: copyright
        dest_path = os.path.join(source_dir, 'debian/copyright')
        write_rendered_template(
            self.jinja2_env, 'debian/copyright.tpl', self.context, dest_path
        )
        # Template: postinst
        dest_path = os.path.join(source_dir, 'debian/postinst')
        write_rendered_template(
            self.jinja2_env, 'debian/postinst.tpl', self.context, dest_path
        )
        # Template: image_desc
        dest_path = os.path.join(source_dir, self.image_desc)
        write_rendered_template(
            self.jinja2_env, 'image_desc.tpl', self.context, dest_path
        )
        self._build_add_file(workdir,
                             self.image_desc,
                             'usr/share/singularity-wrapper/images')
        # Add directory file
        dir_path = self.context['app_path'][1:]
        self._build_add_dir(workdir, dir_path)
        # Finish
        logger.debug("Workdir for wrapper build is ready: %s", workdir)
        return workdir

    def _build_create_parent_dir(self, workdir, path):
        if path == '':
            return
        dirname = os.path.dirname(path)
        abs_dirname = os.path.join(workdir, 'source', dirname)
        if os.path.isdir(abs_dirname):
            return
        self._build_create_parent_dir(workdir, abs_dirname)
        os.mkdir(abs_dirname)

    def _build_add_file(self, workdir, source, target_dir):
        install_file = os.path.join(workdir, 'source/debian/install')
        open(install_file, 'a').write('%s %s\n' % (source, target_dir))

    def _build_add_symlink(self, workdir, path, target):
        links_file = os.path.join(workdir, 'source/debian/links')
        open(links_file, 'a').write('%s %s\n' % (path, target))

    def _build_add_dir(self, workdir, path):
        dirs_file = os.path.join(workdir, 'source/debian/dirs')
        open(dirs_file, 'a').write('%s\n' % path)

    def _build_wrap_add_exe_wrapper(self, workdir, path, exe_path):
        dest_path = os.path.join(workdir, 'source', path[1:])
        self._build_create_parent_dir(workdir, path[1:])
        context = self.context.copy()
        context['exe_path'] = exe_path
        write_rendered_template(
            self.jinja2_env, 'exe_wrapper.sh.tpl', context, dest_path
        )
        self._build_add_file(workdir, path[1:], os.path.dirname(path[1:]))

    def _build_wrap_usr_bin(self, workdir):
        logger.debug("Wrapping files in /usr/bin")
        for package in self.srcPackages:
            pkg = package.pkg
            members = pkg.get_member_names("usr/bin/")
            for member_name in members:
                if member_name[-1:] == '/':
                    # Directory, moving on
                    continue
                target = pkg.get_member_sym_target(member_name)
                exe_path = "/%s" % member_name
                if target is not None and not target.startswith('/opt'):
                    # Symlink to another file outside of /opt
                    # link should work the same
                    if not pkg.is_member(target[1:]):
                        logger.warning(
                            "Target of symlink %s outside the package (%s).",
                            member_name, target
                        )
                    self._build_add_symlink(workdir, exe_path, target)
                else:
                    # If it is not a symlink or if the link points to
                    # a file in /opt, create an exe wrapper
                    self._build_wrap_add_exe_wrapper(workdir, exe_path, exe_path)

    def _build_wrap_add_other_file(self, pkg, workdir, path, source_member):
        content = pkg.get_member_content(source_member)
        dest_path = os.path.join(workdir, 'source', path[1:])
        self._build_create_parent_dir(workdir, path[1:])
        open(dest_path, 'wb').write(content)
        self._build_add_file(workdir, path[1:], os.path.dirname(path[1:]))

    def _build_wrap_other(self, workdir):
        logger.debug("Wrapping other files")
        # Note about desktop files: calibre EDC modifies the desktop
        # files to use "compat-XXX", but since Exe should reference
        # a script in /usr/bin, this seems useless.
        #
        # Note about doc files: calibre EDC copy only copyright and
        # README files, we don't sort that way because its simpler
        # and more comprehensive.
        for package in self.srcPackages:
            pkg = package.pkg
            members = pkg.get_member_names("usr/share/")
            for member_name in members:
                if member_name[-1:] == '/':
                    # Directory,  moving on
                    continue
                target = pkg.get_member_sym_target(member_name)
                file_path = "/%s" % member_name
                if target is None:
                    # If it is not a symlink
                    self._build_wrap_add_other_file(pkg, workdir, file_path, member_name)
                elif not target.startswith('/opt'):
                    # Symlink to another file outside of /opt
                    # link should work the same
                    if not self.package.is_member(target[1:]):
                        logger.warning(
                            "Target of symlink %s outside the package (%s).",
                            member_name, target
                        )
                    self._build_add_symlink(workdir, file_path, target)
                else:
                    # Symlink into /opt
                    self._build_wrap_add_other_file(
                        workdir, file_path, target[1:]
                    )

    def _build_wrap(self, workdir):
        self._build_wrap_usr_bin(workdir)
        self._build_wrap_other(workdir)

    def _build_actual(self, workdir):
        logger.debug("Actually building the package")
        # Launch dpkg build
        source_path = os.path.join(workdir, 'source')
        return_code = subprocess.call(
            ['/usr/bin/dpkg-buildpackage', '-us', '-uc', '-b'],
            cwd=source_path
        )
        logger.debug("Wrapper build returned: %d", return_code)
        if return_code == 0:
            return True
        else:
            logger.error("Failed to build wrapper %s", self.name)
            return False

    def _build_write(self, workdir):
        logger.debug("Writing result package")
        version = self.srcPackages[0].pkg.version
        package_name = "%s_%s_all.deb" % (self.name, version)
        changes_name = "%s_%s_amd64.changes" % (self.name, version)
        for file_name in [package_name, changes_name]:
            source_path = os.path.join(workdir, file_name)
            if os.path.exists(file_name):
                logger.debug("Removing old package: %s" % file_name)
                os.remove(file_name)
            shutil.copyfile(source_path, file_name)

    def _build_clean_workdir(self, workdir):
        if conf.global_skip_clean:
            return
        if os.path.isdir(workdir):
            robust_rmtree(workdir)

    def build(self):
        workdir = self._build_create_workdir()
        self._build_wrap(workdir)
        if self._build_actual(workdir):
            self._build_write(workdir)
        self._build_clean_workdir(workdir)


def parse_conf():
    """Parse configuration file and set runtime configuration accordingly.
       Here are defined default configuration file parameters."""
    defaults = StringIO(
        "[global]\n"
        "skip_clean = False\n"
        "ssl_ca_crt = /etc/ssl/certs/ca-certificates.crt\n"
        "[wrapper]\n"
        "maintainer =  CCN-HPC <dsp-cspito-ccn-hpc@edf.fr>\n"
        "dist = scibian9\n"
        "source_dir = /usr/share/singularity-wrapper/source\n"
        "[images]\n"
        "desc_dir = /usr/share/singularity-wrapper/images\n"
        "build_root = /\n"
        "[recipes]\n"
        "dir = /etc/singularity-wrapper/recipes\n"
        "tpl_name = %{dist}\n"
        "ssl_crt = \n"
        "ssl_key = \n"
        "[repos]\n"
        "active = \n"
        "excluded_deps = compat-calibre7,compat-calibre8,compat-calibre9,compat-scibian9\n"
        "default_arch = amd64\n"
    )
    parser = configparser.RawConfigParser()
    parser.readfp(defaults)
    parser.read(conf.conf_file)
    conf.global_skip_clean = parser.getboolean('global', 'skip_clean')
    conf.global_ssl_ca_crt = parser.get('global', 'ssl_ca_crt')
    conf.images_desc_dir = parser.get('images', 'desc_dir')
    conf.images_build_root = parser.get('images', 'build_root')
    conf.recipes_dir = parser.get('recipes', 'dir')
    conf.recipes_tpl_name = parser.get('recipes', 'tpl_name')
    conf.recipes_ssl_crt = parser.get('recipes', 'ssl_crt')
    conf.recipes_ssl_key = parser.get('recipes', 'ssl_key')
    conf.wrapper_maintainer = parser.get('wrapper', 'maintainer')
    conf.wrapper_dist = parser.get('wrapper', 'dist')
    conf.wrapper_source_dir = parser.get('wrapper', 'source_dir')
    conf.repos_active = parser.get('repos', 'active').split(',')
    conf.repos_excluded_deps = parser.get('repos', 'excluded_deps').split(',')
    conf.repos_default_arch = parser.get('repos', 'default_arch')
    conf.repos = {}
    for section in parser.sections():
        if not section.startswith('repo:'):
            continue
        name = section[5:]
        repo = {}
        repo['base_url'] = parser.get(section, 'base_url')
        repo['dist'] = parser.get(section, 'dist')
        repo['dist_release'] = parser.get(section, 'dist_release')
        repo['ssl_key'] = None
        if parser.has_option(section, 'ssl_key'):
            repo['ssl_key'] = parser.get(section, 'ssl_key')
        if repo['ssl_key'] == '':
            repo['ssl_key'] = None
        repo['ssl_crt'] = None
        if parser.has_option(section, 'ssl_crt'):
            repo['ssl_crt'] = parser.get(section, 'ssl_crt')
        if repo['ssl_crt'] == '':
            repo['ssl_crt'] = None
        repo['components'] = parser.get(section, 'components').split(',')
        repo['archs'] = parser.get(section, 'archs').split(',')
        conf.repos[name] = repo


def parse_args():
    """Parses CLI args, then set debug flag and configuration file path in
       runtime configuration accordingly, and returns the args."""
    parser = argparse.ArgumentParser()

    parser.add_argument('-d', '--debug',
                        help='Enable debug mode',
                        action='store_true')

    parser.add_argument('-I', '--one-image',
                        help='Wrappe packages to one image',
			            dest='oneImage',
                        action='store_true')
                        
    parser.add_argument('-c', '--conf',
                        help='Path to the configuration file',
                        nargs='?',
                        default='/etc/singularity-wrapper/config.ini')

    parser.add_argument('-D', '--distribution',
                        help='Source distribution for the wrapper creation',
                        nargs='?',
                        default=None)

    parser.add_argument('action',
                        help='Action to perform',
                        nargs='?', choices=[
                            'repo-query',
                            'wrapper-create',
                            'image-build',
                            'image-list'
                        ],
                        default='image-list')

    parser.add_argument('target_list',
                        help='List of targets for the action',
                        nargs='*',
                        default=[])
    
 
    args = parser.parse_args()
    if args.debug:
        conf.debug = True
    if args.conf:
        conf.conf_file = args.conf
    if args.oneImage:
        conf.oneImage = True

    return args


def setup_logger():
    if conf.debug is True:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)
    handler = logging.StreamHandler()
    formatter = logging.Formatter('%(levelname)s: %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)


def write_rendered_template(env, template, context, dest_path):
    tpl = env.get_template(template)
    rendered_content = tpl.render(context)
    open(dest_path, 'w').write(rendered_content)


def download_file(file_path, url, ssl_crt=None, ssl_key=None):
    logger.debug("Downloading %s to %s.", url, file_path)
    parsed_url = urllib.parse.urlparse(url)
    if parsed_url.scheme == 'https':
        context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
        if ssl_key is not None and ssl_crt is not None:
            context.load_cert_chain(ssl_crt, ssl_key)
        context.load_verify_locations(conf.global_ssl_ca_crt)
        context.verify_mode = ssl.CERT_REQUIRED
        context.check_hostname = True
        conn = http.client.HTTPSConnection(parsed_url.netloc, context=context)
    elif parsed_url.scheme == 'http':
        conn = http.client.HTTPConnection(parsed_url.netloc)
    else:
        raise Exception(
            "Unknown scheme in URL (%s): %s" % (url, parsed_url.scheme)
        )
    conn.request("GET", parsed_url.path)
    response = conn.getresponse()
    if response.status < 200 or response.status >= 300:
        raise Exception(
            "Download of URL %s failed with error %s" % (url, response.status)
        )

    output = open(file_path, 'wb')
    output.write(response.read())
    conn.close()
    output.close()


def robust_rmtree(path):
    """
        The shutils.rmtree fails randomly on NFS, so wrap it in
        retries
    """
    max_retries = 5
    for i in range(max_retries):
        try:
            shutil.rmtree(path)
            return
        except OSError:
            logger.warning('Failed to remove directory: %s' % path)
            if i == (max_retries - 1):
                raise
            time.sleep(i)


def get_image_descs():
    dir_content = os.listdir(conf.images_desc_dir)
    image_descs = {}
    for element in dir_content:
        # ignore hidden files
        if element.startswith("."):
            continue
        file_path = os.path.join(conf.images_desc_dir, element)
        if not os.path.isfile(file_path):
            continue
        logger.debug("Creating image description for %s", element)
        desc = ImageDesc(element, file_path)
        image_descs[element] = desc
    return image_descs


def parse_targets(args):
    targets = []
    for element in args.target_list:
        targets += element.split(',')
    return targets


def get_images(targets=None):
    images_desc = get_image_descs()
    images = {}
    for name, desc in images_desc.items():
        if targets is not None and name not in targets:
            continue
        img = Image(name, desc)
        img.refresh_state()
        images[name] = img
    return images


def get_repositories():
    repositories = {}
    for name in conf.repos_active:
        repositories[name] = Repository(name)
    return repositories


def action_repo_query(targets=None, filter_dist=None):
    if targets is not None and len(targets) == 0:
        targets = None
    repositories = get_repositories()
    for name, repo in repositories.items():
        if filter_dist is not None and filter_dist != repo.dist_release:
            continue
        packages = repo.get_packages(
            queries=targets,
            excluded_deps=conf.repos_excluded_deps
        )
        for pkg_name, pkg_info in packages.items():
            print("%s, Repository:%s, Version:%s" % (
                pkg_name, name, pkg_info['Version']
            ))


def action_wrapper_create(targets=None, default_dist=None, filter_dist=None):
    if targets is None:
        targets = []
    repositories = None
    remaining_targets = []
    # packages temporary downloaded, that should be cleaned
    to_clean = []

    packages = {}
    for target in targets:
        if os.path.isfile(target):
            package = BinaryPackage(target)
            packages[package.name] = {
                'source_dist': default_dist,
                'package': package,
            }
        else:
            remaining_targets.append(target)

    for target in remaining_targets:
        if repositories is None:
            repositories = get_repositories()
        for repo in repositories.values():
            if filter_dist is not None and filter_dist != repo.dist_release:
                continue
            package = repo.get_package(target)
            if package is None:
                continue
            logger.debug("Found package %s in %s for target %s",
                         package.name, repo.name, target)
            if package.name in packages.keys() \
                    and repo.dist_release != default_dist:
                # replace already found package only if default dist
                continue
            packages[package.name] = {
                'source_dist': repo.dist_release,
                'package': package
            }
            to_clean.append(package.name)

    if len(packages) < 1:
        logger.warning("No matching package to wrap.")
    
    if conf.oneImage:
        wrapper = Wrapper(packages)
        wrapper.build()
    else:
        pkgs = [{k:v} for k,v in packages.items()]
        length = len(pkgs)
        for i in range(length):
            wrapper = Wrapper(pkgs[i])
            wrapper.build()
        
		
    for pkg in packages.values():
        if (pkg['package'].name) in to_clean:
	        os.remove(pkg['package'].realpath)


def action_image_list(targets=None):
    if targets is not None and len(targets) == 0:
        targets = None
    images = get_images(targets)
    for name, img in images.items():
        print("%s, Status:%s, Path:%s, Packages:%s" % (
              name,
              Image.get_status_string(img.status),
              img.path,
              ';'.join(img.desc.app_packages)
              ))


def action_image_build(targets=None):
    images = get_images(targets)
    for image in images.values():
        image.build()


def main():
    locale.setlocale(locale.LC_ALL, LOCALE)
    os.environ['LANG'] = LOCALE
    args = parse_args()
    setup_logger()
    parse_conf()
    conf.dump()

    if args.distribution is not None:
        default_dist = args.distribution
        filter_dist = args.distribution
    else:
        default_dist = conf.wrapper_dist
        filter_dist = None

    targets = parse_targets(args)
    
    if args.action == 'wrapper-create':
        action_wrapper_create(targets, default_dist, filter_dist)
    elif args.action == 'image-list':
        action_image_list(targets)
    elif args.action == 'image-build':
        action_image_build(targets)
    elif args.action == 'repo-query':
        action_repo_query(targets, filter_dist)
    else:
        logger.error("No valid action provided. (%s)" % args.action)
        sys.exit(1)

conf = AppConf()  # global runtime configuration object
if __name__ == '__main__':
    main()
